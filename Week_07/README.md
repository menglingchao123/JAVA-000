学习笔记
### 锁
1. set autocommit = 0 ====> 手动提交事务
2. set autocommit = 1 ====> 自动提交事务
3. begin 开启事务 rollback 回滚事务 commit 提交事务
4. select * from t where id =1 for update; ======> id=1行记录上行锁
5. select database() ======> 查询数据库
6. show engine innodb status /g; =====> 查询innodb引擎执行状态
7. information_schema库-INNODB_LOCKS表查询引擎状态
8. select * from xxx lock in share mode =====> 设置共享锁
### 事务
#### 事务可靠性模型ACID
1. Atomicity:原子性,一次事务操作要么全部成功,要么全部失败

### sql优化
1. order by if(t.col > 6 ,-t.col , t.col) 按字段返回正负去排序
#### SQL分析

1. 如何发现SQL问题
 - 慢查询日志 slowlog慢查询日志文件
    - Rank
    - Response Time 响应时间
    - Rows examine 扫描行锁
    - min
    - max
    - avg
 - 查看应用与运维监控
    - tps ===> 交易量
    - 延迟 ===> 慢SQL
2. 了解SQL优化的方法
 - 添加索引 (B+tree(叶子节点带数据其他节点都是主键) , hash)
3. SQL优化有哪些好处
#### 索引类型
1. hash索引
![07ee36b3a73b9f07bff48d27accbde53.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p108)
2. B+tree索引
![ac0ae774a9abcc9fb830d0bc6e8b15a4.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p109)
#### 字段数据类型选择
![4368cc5de9ef34c3414599a8f5e87269.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p106)
数据类型影响
 - 网络传输
 - 数据存储大小,数据页存储越大，索引性能好
1. Number 数字
 - 数字后面长度没有实际意义,不影响存储长度
2. String 字符
3. Time 时间
#### 引擎选择
![0b7bfeac85141ba9bb3535cececb4bf2.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p107)
1. 热数据:INNODB引擎 搜索引擎 缓存
2. 温数据:nosql数据库 例如Hbase mongoDB
3. 冷数据:磁盘 ToKuDB(数据压缩好)
#### 表设计
1. 编码类型 ======> utf8mb4(mysql8.0默认字符集),数据库设计规范
#### mysql不规范说明
1. 隐式转换
 - 数据类型之间可以相互转换 ======> int to char
 - 带来问题 =====> 不走索引
2. 敏感信息不出现在SQL中
 - 银行卡 身份证 密码
#### 索引选择
1. 主键查询与普通索引查询区别
    - 聚集索引: 主键的B+TREE数据结构与数据放在一起的
    - 普通索引: 普通索引的数据结构不与数据放在一起,存储的是id,根据id进行回表查询
2. 字段选择性 - 最左规则
    - 选择性:字段值重复程度,重复越低选择性越好,反之越差
    - F = DISTINCT(col)/count(*)
3. 冗余索引
   - 问题:造成索引文件过大,降低查询效率和插入更新效率
4. 修改表结构危害
    - 锁表
    - 索引重建 (表结构改变造成)
    - 抢占资源(锁表造成)
    - 主从延时
5.表结构变更情况
    - 字段类型修改
    - 新增字段 - 增加子表
    - 新增查询索引
#### 主键选择
![1bee6dc755cd45708e0f314ffc0b0c7c.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p110)
1. 自增主键,效率高,插入数据不会改变原有数据,如果不是自增会改变元素存储位置,改变数据存储
### 写入优化
1. PreparedStatement#addBatch()减少SQL解析
2. Multiple Values/addBatch() 
    - 减少交换
    - SQL解析不友好
    - 查询写法:select * from t where (id,col1) = (1,1)
3. Load Data 直接导入
4. 索引和约束问题
    - 导入数据去掉索引和约束,有利于性能提升,避免多次索引文件修改造成性能损耗
### 数据更新优化
1. 更新范围注意Gap锁问题,避免锁范围扩大
2. 更新尽量根据主键精确更新
### 模糊查询
1. Like查询,xxx%前缀匹配否则不走索引
2. 全文检索 SOLR ES(数据量大查询条件多)
3. 索引只建在关键字段
4. 数据改动小,查询频率高,通过缓存查询
### 连接查询
1. 驱动表选择
    - 减少SQL复杂度
    - 查询数据量
2. 笛卡尔积
### 索引失效
1. not null not in 函数
2. 去or
    - in
    - union(可以去重复)
3. 强制指定查询索引 force index
### 查询SQL设计
1. 查询次数和查询数据量平衡
2. 避免使用临时文件排序或者临时表(file sort)
3. 分析类数据,可以使用汇总表 (通过定时任务进行数据汇总)，通过冗余和中间层
### 自增主键
1. 单机
    - 数据库自带策略例如 mysql auto_increment
2. 分布式
    - UUID
    - 自定义(select from t for update)
    - 时间戳/随机数
    - snowflake
        - 不依赖中心点,机器之间可以各自计算
        - 同一机器按时间顺序自增
        - 不存在数据泄露风险
### 分页查询优化

1. 不使用插件,手工count()
2. 查询最后几条数据 , 反向排序方式
3. 非精确分页,带id向后查询方式


### 乐观锁和悲观锁
1. select * from xxx for update; update xxx commit;
    - 性能差
    - 阻塞事务
2. select * from  ... update xxx set... where value=oldvlaue;
    - ABA

-----------------------------------------------------------------------

### 读写分离
#### 动态切换数据源版本1.0 -- Spring配置多数据源
![ad8e0c46ab1c793127354760b0eaaa61.png](evernotecid://516996F9-1252-4EFC-AC10-228CA09F63B5/appyinxiangcom/31649193/ENResource/p111)
1. 基于Spring/springboot，配置多数据源(例如master和slave)
2. 应用系统是数据库是割裂开的,应用系统是感知不到数据库的主从配置的
3. 根据service方法是否操作数据源和操作方式,注入不同数据源,1.0版本
4. 改进1.1版本通过springboot的AbstractRoutingDataSource和自定义注解@Readonly之类进行简化数据源配置
    - 正常事务通过主库
    - 只读通过从库
5. 支持配置多从库
6. 多从库之间负载均衡算法
7. 1.0版本存在问题
   - 侵入性强,需要手工标注读和写操
   - 主库和从库之间存在数据延迟,造成写操作和读不一致问题
#### 数据库框架版本2.0
1. 改进方式ShardingSphere-jdbc的Master-Slave功能
    - SQL解析(识别读和写操作)和事务管理,实现自动读写分离
    - 解决读写不一致问题
        - 一个事务内,存在写操作,后面读操作都走主库
2. 存在问题
    - 业务系统存在侵入性,需要引入相关的jar包和相关的配置
    - 已存在的旧系统改造不友好
#### 数据库中间件版本3.0
1. 改进方式,使用shardingSphere-proxy的Master-Slave功能
    - proxy可以模拟一个Mysql，对业务系统无侵入
    - 需要部署一个中间件,规则配置在中间件
    - app -> proxy -> mysql
    - proxy实现了数据库相关协议
### 高可用
1. 高可用定义:更少不可用服务时间
    - 指标:正常服务时间/总服务时间
    - SLA:服务水平协议
2. 服务不可用指标
- 1年 = 365天 = 8760小时 99 = 8760 * 1% = 8760 * 0.01 = 87.6小时 
- 99.9 = 8760 * 0.1% = 8760 * 0.001 = 8.76小时 
- 99.99 = 8760 * 0.0001 = 0.876小时 = 0.876 * 60 = 52.6分钟
- 99.999 = 8760 * 0.00001 = 0.0876小时 = 0.0876 * 60 = 5.26分钟
3. 通过冗余和增加集群数量方式提高系统可用性
#### mysql的高可用
1. 读写分离,提高读的处理能力,也可以有更多资源处理写的能力
2. 故障转移,提供failover能力,主库宕机后从库自动代替主库
3. 业务系统的数据库连接池的断线重连机制，保证业务不间断
4. RTO和RPO
 - RTO：业务恢复
 - RPO：数据恢复
#### 高可用存在意义
1. 性能 稳定性 故障转移
2. failover:主节点宕机,从节点代替主节点继续提供服务
3. 冷备:平时不提供服务,主机出现故障时候代替主机提供服务,保证对外正常提供服务
4. 热备:平时提供服务
5. 常见的一些策略：
 1、多个实例不在一个主机/机架上 
 2、跨机房和可用区部署 
 3、两地三中心容灾高可用方案 同城两个,异地三个
#### Mysql高可用0 - 主从手动切换
1. 如果主节点挂了,需要将某个从改成主,需要重新配置其他从节点,修改应用数据源配置
2. 问题:
    - 可能数据不一致,需要将没有同步过来的binlog日志数据同步过来
    - 需要人工干预
    - 代码和配置侵入性
#### Mysql高可用1 - 主从手动切换
1. 用LVS+Keepalived实现多个节点的探活+请求路由
2. 配置VIP或者DNS实现配置不变更
3. 问题
    - 手动处理主从配置(应用系统不需要，切换外部系统配置)
    - 大量配置和脚本定义
#### Mysql高可用2 - MHA
1. 一般在30s内完成主从切换,直接通过ssh复制主节点日志
2. 问题
    - 需要配置ssh信息
    - 至少3台
#### Mysql高可用3 -MGR
1. MGR的主从配置是存在表中,应用系统需要通过读取表中数据获取主从关系,主从关系发生变化时会重新确定主从关系,更新表数据
2. 主节点挂掉,将某个从节点变成主节点,无需人工干预,通过组复制方式保持主从数据一致性