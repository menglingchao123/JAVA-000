学习笔记
### GC日志分析

1. 命令行  

```

(1)java -XX:+PrintGCDetails GCLogAnalysis 打印GC日志详情

(2) java -Xloggc:gc.demo.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis 打印GC日志详情和执行时间点到日志文件中

(3)发生young gc时:

a.eden -> survivor

b.young -> old

c.一部分对象会被GC回收

(4)日志文件参数解析:

a.real是应用程序暂停时间

```

2. 发生内存溢出的情况分析

```

(1)当经过多次fullGC后内存仍然不够用的情况下,可能会出现内存溢出,中间可能发生old区内存不下降反而升高情况,因为新生代发生GC时会把数据过渡到老年代。

(2)当堆内存比较小时,适当增大堆内存大小后可以解决内存溢出问题,还可以提高系统运行效率,减少了fullgc次数。

(3)适当提升堆内存大小可能降低oom概率,可能减少GC次数。

(4)内存过大可能会造成,GC回收时间变长,降低应用系统执行效率,所以内存大小要适度。
```
3. GC日志解读

```

(1)youngGC发生时会young区内存发生变化

(2)fullGC发生时young区和old区都会发生变化

(3)minor GC是小型的GC指的是young区GC,majorGC是old区GC

(4)不同的GC策略不同,一般fullgc发生时,young区和old区都会被回收。

```

### 分析使用不同GC的运行情况

1. serial GC

```

(1)串行GC执行fullgc时只会回收old区的内存

(2)gc效率比较低,可能会造成系统暂停时间比较长

(3)当young区经过gc时内存没有被回收掉,造成内存空间不足，一部分存活对象直接进入old区

```

2. parallel GC

```

(1) 比如执行时间和内存下降率和发生younggc和fullgc次数

(2)young gc时只回收young区

(3)fullgc时会回收old和young区

```

3. CMS GC

```

(1)重要参数并发线程数量

(2)并发线程太高,会和业务线程抢资源会出现cup上线文切换过于频繁,并发线程太少gc效率过低

```

4. G1 GC

```

 (1)当内存比较高时候,g1GC能会好一些 

```

5. 数据分析情况

```

(1)young区大部分数据会被回收掉，存活率比较低

(2)old区对象存活时间比较长,gc回收率比较低 

(3)相同Xmx512m内存情况下,serialGC效率比ParallelGC效率高

(4)如果不配置Xms=Xms,第一次younggc时间可能会提前,因为Xms初始化大小可能比较小

(5)当内存比较小,可能会频繁引发fullgc,当内存比较高时候fullgc发生次数相对少一些

```

### 线程堆栈数据分析
1. java中线程会真实绑定OS的线程
2. 线程的执行流程

```

Thread#start() -> thread对象 -> 系统线程 -> OSThread -> stack -> TLAB(young专门为线程设置的内存区域) -> 启动 -> Thread#run() -> 终止 -> Terminate

```

3. 层面
```
(1) java层面，对象层面
(2) jvm内部层面
(3) 操作系统层面
```
4. jvm内部线程分类
```
VM 线程：单例的 VMThread 对象，负责执行 VM 操作
下文将对此进行讨论;

定时任务线程：单例的 WatcherThread 对象，模拟在VM 中执行定时操作的计时器中断；
GC 线程：垃圾收集器中，用于支持并行和并发垃圾回收的线程

编译器线程： 将字节码编译为本地机器代码,多次执行代码,jvm会将字节码优化为机器码

信号分发线程：等待进程指示的信号，并将其分配给Java级别的信号处理方法。
```
5. 安全点
```
a. 方法代码中被植入的安全点检测入口；
b. 线程处于安全点状态：线程暂停执行，这个时候线
程栈不再发生改变；
c. JVM 的安全点状态：所有线程都处于安全点状态。
```
6. JVM 支持多种方式来进行线程转储
```
a. JDK 工具, 包括: jstack 工具, jcmd 工具, jconsole,jvisualvm, Java Mission Control 等；

b. Shell 命令或者系统控制台, 比如 Linux 的 kill -3,Windows 的 Ctrl + Break 等；
c. JMX 技术， 主要是使用 ThreadMxBean。
```
7. 死锁
```
(1) 线程获取一个锁同时想获取另外一个锁,但是另外线程正在占用这个锁,当前线程占有的锁是另外一个线程的需要的锁,造成双方都会释放这个锁。
(2) 解决死锁的方法:
 a. 加超时时间,过了这个时间自动解锁
 b. 强制终止一个线程的，解开死锁
```
### 内存分析与相关工具
1. 对象内存分布
```
(1) Instrumentation#getObjectSize()可以估算对象内存大小,对象所有字节必须是 8字节倍数。
(2)对象头: 标记字,class指针,数组长度
(3)对象体：实例数据(字段),内部空白(padding)
(4)外部对齐: alignment
(5)查看对象具体分布:第三方工具 jol(java object layout)
```
2. 对象头和引用 
```
(1) 在64位 JVM 中，对象头占据的空间是 12-
byte(=96bit=64+32)，但是以8字节对齐，所以一
个空类的实例至少占用16字节。
(2) 在32位 JVM 中，对象头占8个字节，以4的倍数对
齐(32=4*8)。
(3) 通常在32位 JVM，以及内存小于 -Xmx32G 的64位
JVM 上(默认开启指针压缩)，一个引用占的内存默认是4个字节。
(4) 头部 压缩指针 补齐部分会浪费一部分内存空间
```
3. 包装类型
```
(1) 比原生类型浪费更多内存空间
(2) Integer：占用16字节(8+4=12+补齐)，因为 int 部分占4个字节。 所以使用 Integer 比原生类型 int 要多消耗 300% 的内存。
(2) Long：一般占用16个字节(8+8=16)，当然，对象的实际大小由底层平台的内存对齐确定，具体由特定 CPU平台的 JVM 实现决定。 看起来一个 Long 类型的对象，比起原生类型 long 多占用了8个字节（也多消耗了100%）。
(3) int 4字节 , long 8字节
```
4. 二维数组
```
(1) 在二维数组中每个嵌套数组相当于一个Object对象会额外占用16字节空间,当数组维度越大,内存开销比较明显。
(2) 创建数组时尽量让前面数小后面数大。
```
5. 字符串
```
String: String 对象的空间随着内部字符数组的增
长而增长。当然，String 类的对象有24个字节的额
外开销。
```

5. 发生OOM情况

主要原因:创建新对象时,堆内存空间不足以存放新的对象。
```
(1) 出现死循环，不对向一个对象放数据造成内存溢出
(2) 堆内存配置过小,内存不足以创建对象,但是垃圾回收又不能回收掉存活的对象造成内存溢出。
(3) 解决方案: 适当增加堆内存大小
```
6. OutofMemoryError:permGen space /OutofMemoryError:Meta space
```
主要原因:
（1）加载到内存中的class数量太大或者体积太大,超过permGen space
 (2) 解决方案: 增加PermGen / Metaspace
 -XX:MaxPermSize = 1024m
 -XX:MaxMetaspaceSize = 1024m
（3）高版本JVM可以:
 -XX:+CMSClassUnloadingEnabled
 (4)jdk8以后默认无限大，当内存小时，需要设置适当值
```
7. Metaspace主要存储类结构信息

线程相关OutOfMemoryError:Unable to create new native thread 
```
(1)不同操作表现不同：
a. unix或者linux表示一切操作都是文件
(2)解决方案:
a. 降低Xss参数
b. 调整代码,改变线程创建方式
c. 调整系统参数 :
ulimit -a，echo 120000 > /proc/sys/kernel/threads-max
(3)设置线程过多,cup线程上下文切换过高,可能会影响执行效率
```

8. 内存Dump分析工具
```
Eclipse MAT
jhat
```
9. 调优经验
高分配速率(High Allocation Rate)
```
(1)分配速率(Allocation rate)表示单位时间内分配的内存量。通常使用 MB/sec 作为单位。上一次垃圾收集之后，与下一次 GC 开始之前的年轻代使用量，两者的差值除以时间,就是分配速率。
分配速率过高就会严重影响程序的性能，在 JVM 中可能会导致巨大的 GC 开销。

正常系统：分配速率较低 ~ 回收速率 -> 健康

内存泄漏：分配速率 持续大于 回收速率 -> OOM

性能劣化：分配速率较高 ~ 回收速率 -> 压健康

(2)GC 分配速度过快,回收速度也过快可能会造成垃圾回收执行频率比较高, 影响业务线程执行，造成系统性能差。
```
10. 蓄水池效应
```
(1) 思考一个问题，

分配速率，到底影响什么？

想一想，new 出来的对象，在什么地方。

答案就是，Eden。

假如我们增加 Eden，会怎么样。

考虑蓄水池效应。

最终的效果是，影响 Minor GC的次数和时间，进而影响吞吐量。

在某些情况下，只要增加年轻代的大小，即可降低分配速率过高所造成的影响。

增加年轻代空间并不会降低分配速率，但是会减少 GC 的频率。如果每次 GC 后

只有少量对象存活，minor GC 的暂停时间就不会明显增加。

(2) 增加蓄水池高度会减少young gc次数,单次gc时间可能会有增加,总体gc时间会减少

```

11. 过早提升

```

(1) 过早提升,可能导致对象进入old区很快被回收,这与我们的分代假设是相背的,会造成old区gc处理垃圾对象增多,从而导致fullgc时间变长，从而影响程序运行。

(2) 提升速率（promotion rate）用于衡量单位时间内从年轻代提升到老年代的数据量。一般使用 MB/sec 作为单位, 和分配速率类似。

JVM 会将长时间存活的对象从年轻代提升到老年代。根据分代假设，可能存在一种情况，老年代中不仅有存活时间长的对象,也可能有存活时间短的对象。这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代。

major GC 不是为频繁回收而设计的，但 major GC 现在也要清理这些生命短暂的对象，就会导致 GC 暂停时间过长。这会严重影响系统的吞吐量。

```

12. 过早提升表现

```

一般来说过早提升的症状表现为以下形式：

短时间内频繁地执行 full GC

每次 full GC 后老年代的使用率都很低，在10-

20%或以下

提升速率接近于分配速率

要演示这种情况稍微有点麻烦，所以我们使用特殊

手段，让对象提升到老年代的年龄比默认情况小很

多。指定 GC 参数 -Xmx24m -XX:NewSize=16m

-XX:MaxTenuringThreshold=1，运行程序之后，

可以看到下面的 GC 日志。

young区进入old区途径:

a.young放不下

b.对象晋升

```

13. 解决方案:

```

Xmx64m -XX:NewSize=32m，程序在执行时，Full GC 的次数自然会减少很多，只会对 minor GC 的持续时间产生影响。

二是减少每次批处理的数量，也能得到类似的结果。

至于选用哪个方案，要根据业务需求决定。 在某些情况下，业务逻辑不允许减少批处理的数量，那就只能增加堆内存，或者重新指定年轻代的大小。 如果都不可行，就只能优化数据结构，减少内存消耗。但总体目标依然是一致的：让临时数据能够在年轻代存放得下。

```

### 疑难问题分析

1. 排查问题思路

```

(1) 定位问题方法:

a. 查看日志和其他监控手段的各种指标是否符合正常值

(2) 查询手段:

1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等， 基础服务、外部 API 依赖 。

2、查看系统资源和监控信息：

硬件信息、操作系统平台、系统架构；

排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞争等情况；

排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、超时、连接数。

3、查看性能指标，包括实时监控、历史数据。可以发现 假死，卡顿、响应变慢等现象；

排查数据库， 并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询数据量、redo日志、undo、 binlog 日志、代理、工具 BUG。可以考虑的优化包括： 集群、主备、只读

实例、分片、分区；

大数据，中间件，JVM 参数。

4、排查系统日志， 比如重启、崩溃、Kill 。

5、APM，比如发现有些链路请求变慢等等。

6、排查应用系统

排查配置文件: 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、APM 配置、内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC 问题等;

GC 问题， 确定 GC 算法、确定 GC 的 KPI，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标： 内存

分配速度，分代提升速度，内存使用率等数据。适当时修改内存配置；

排查线程, 理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁；

排查代码， 比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方库、XSS、CORS、正则；

单元测试： 覆盖率、边界值、Mock 测试、集成测试。

7、 排除资源竞争、坏邻居效应

8、疑难问题排查分析手段

DUMP 线程\内存；

抽样分析\调整代码、异步化、削峰填谷。

(3) 连接池配置，连接数一般在20-50

(4)日志打印: 异步打印log,通过其他线程

(5)考虑每个参数调整系统带来实际影响。

``` 

### 系统压力测试

并行gc与cms在512m内存下对比，cms吞吐量更高

Xmx4g情况下,cms比并行低

吞吐量和延迟关系,一般吞吐量越高,延迟越低

G1参数并发执行线程数,期望暂停时间

指标:gc发生次数,gc吞吐量,停顿时间,从而去验证之前的结论





-------------------------------------------------------------------------




### 服务器通信原理

1. Socket通信模型

```
(1)服务创建监听端口
(2)客户端通过监听端口,与服务器建立连接
(3)服务收到建立连接请求后开始通信
(4)InputStream读取数据
(5)OutputStream写入数据
(6)端口:区分一个机器上面进程
(7)机器上面可能存在多个网卡,每个网卡都有一个对应ip
(8)绑定机器上面所有网卡(ip)可以绑定0.0.0.0
```
2. 简单的java http服务完全串行
3. 建立连接socket连接后,启动多线程处理请求
4. 固定长度线程池
```
(1)线程数可以适当加大，IO过程中会产生阻塞
```
5. 服务器通信过程分析计算机处理操作
```
(1)IO操作，例如:网络 ，数据库 ，磁盘读写
(2)cup计算处理 例如:业务处理

```
6. 用户到内核数据拷贝问题
```
用户空间->缓存区->内核空间->Socket
```
7. CUP在IO处理过程中等待
```
(1)创建新创数量比较多,线程之间频繁上线文切换会消耗很多资源
(2)Io操作过程是会存在等待,这时候是不会占用cup的
(3)IO密集型线程数大,cup密集型线程数是内核数
    a.不与网络，磁盘相关交互，通过内存进行计算的CUP密集型
    b.服务通信，数据库操作，这种是IO密集型
(4)将相互不干扰的步骤,拆分开用多个线程执行
```
### NIO模型
1. 同步 异步是通信模型
```
同步：调用一个方法等待方法返回后确定下一步操作
异步：调用一个方法,然后方法处理后通过回调函数方式通知执行结果
```
2. 阻塞 非阻塞是线程处理模式 
3. 阻塞IO BIO模型
```
处理线程是跟内核交互,不直接跟网络交互
内核读取数据后唤醒线程,将内核数据复制到用户空间
```
4. 非阻塞IO
```
(1)第一阶段：内核数据没有准备，但是会立刻返回
(2)用户不断向内核询问数据准备情况
(3)内核将数据发送给用户
```
5. IO模型3
```
(1)将Socket通道绑定到selector
(2)selector观察数据数据准备好的通道
(3)将准备好的通道数据复制到用户空间
```

4. select/poll的缺点:
```
(1)每次调用select,都需把fd集合从用户态拷贝到内核态,这个开销在fd很多时会很大
(2)每次调用select都需要在内核遍历传递进来的所有fd,这个开销在fd很多时也很大
(3)select支持的文件描述数量太小,默认是1024
```
5. epoll
```
(1)内核与用户空间共享一块内存
(2)通过回调解决遍历
(3)fd没有限制,可以支持10万连接
```
6. 事件IO
```
(1)用户告知内核需要数据
(2)用户等待数据时,可以做其他事情
(3)系统通知用户数据准备好
(4)调用读取数据,复制到用户空间
```

6. 线程池->EDA->SEDA
7. 异步IO
```
windows的IOCP模型 proactor
(1)用户向内核发出调用请求后立刻返回
(2)系统准备数据
(3)准备好将数据复制到用户进程缓冲区
(4)通知用户io完毕
```
### Netty网络应用框架
```
(1)异步
(2)事件驱动
(3)基于NIO
```
1. 适用于
```
（1）服务端
 (2) 客户端
 (3) TCP/UDP/websocket/http
```

2. Netty特性
```
高性能的协议服务器:
• 高吞吐
• 低延迟
• 低开销
• 零拷贝
• 可扩容
• 松耦合: 网络和业务逻辑分离
• 使用方便、可维护性好
```
3. 基本概念
```
• Channel
通道,Java NIO中的基础概念,代表一个打开的连接,可执行读取/写入IO操作。
Netty对Channel的所有IO操作都是非阻塞的。
• ChannelFuture
Java的Future接口，只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。
Netty封装一个 ChannelFuture 接口。
我们可以将回调方法传给 ChannelFuture，在操作完成时自动执行。
• Event & Handler 
Netty基于事件驱动，事件和处理器可以关联到入站和出站数据流。
• Encoder & Decoder
处理网络IO时，需要进行序列化和反序列化, 转换Java对象与字节流。
对入站数据进行解码, 基类是 ByteToMessageDecoder。
对出站数据进行编码, 基类是MessageToByteEncoder。
• ChannelPipeline
数据处理管道就是事件处理器链。
有顺序、同一Channel的出站处理器和入站处理器在同一个列表中。
```